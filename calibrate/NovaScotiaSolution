Nova Scotia Solution(NSS) for Magnetometer Calibration and Operation
---------------------------------------------------------------
This algorthm is for PeterMacleodThompson board 
although it has applicability to any magnetometer. 

Magnetometer
------------
Earth's magnetic field is 25-65 uTesla - 50 uTesla on average
x = magnetic north(+) south(-) field strength
y = magnetic east(+) west(-)  field strength
z = magnetic field strength vertically down (ignored in this algorithm)

NOTE of Confusion 
-----------------
The Cartesian Coordinate System with xy-plane
    has counter-clockwise degrees starting at 0 on x-axis.
Compass bearings have clockwise degrees with 0 starting at North
     which normally is viewed as y axis.  
Aerospace/NED Standard (NED=North, East, Down) has X-axis North, Y-axis East
      and Z-axis Down.  Degrees are counter-clockwise.  Freescale AN4696
Android Standard has Y-axis North, X-axis East, Z-axis Up. 
       Degrees are counter-clockwise. Freescale AN4696
Windows 8 has Y-axis North, X-axis East, Z-axis Up. 
       Degrees are counter-clockwise. Freescale AN4696
This Nova Scotia Solution (NSS) has X-axis North, Y-axis East, Z-axis not applicable.
       Degrees are counter-clockwise.
In other words, NSS uses compass bearings and 2 dimensions.   
This is NOT a tilt compensated algorithm as is documented in many magnetometer
calibrations.  



Calibration (x,y only)
----------------------
Raw magnetometer readings (uTesla) are a normal distribution 
around an ellipse located anywhere on the xy-plane.
Calibration converts raw magetometer readings (uTesla) to a
circle centered on (0,0)  with radius and standard deviation. 
For example,  mean radius of 19.4 uTesla (for Calgary, Canada) and
a standard deviation of 1.4 uTesla (7.2%) works. 

The calibration is in 2 parts:
  1. Hard Iron Calibration moves the ellipse from anywhere to (0,0) center. 
  2. Soft Iron Calibration converts the ellipse to a circle. 


Calibration Process
-------------------
You are trying to create an exact circle centered on (0.0)
from the data produced by the fxos8700.   Because of electrical
interference, the fxos8700 will produce an off center circle (hard iron)
which might be an ellipse (soft iron).    

Step 1 - Set up flat level non-metalic table for calibration.
   Using a compass, stick tape aligned magnetic north/south on table.
   Draw a perpendicular line at 90 degrees for east/west on the tape.
   Mark North, South, East West on tape.
   Be sure that North South East West markings make sense. 

Step 2 - Position the device board on lab table.
   Place the board so the label "PeterMacleodThompson" runs 
   on the North/South axis and "P" is North and "n" is South.
   Standing South and looking North, "Linx" script should be upside-down.
   If you are unsure of magnetic north, 2 orthogonal axis will
   probably work. 
    
Step 3 - Start  Calibration-Phase 1 - and follow the instructions.
   You will be asked to Place device 4 times (4 samples) for each of
   North, East, South, West orientations.  This gathers 4 orthogonal samples of
   data from fxos8700: magdata0, magdata90, magdata180, magdata270.  
   These are used to calculate hard iron calibration which, when finished, 
   is stored in the Calibration Record - calibdata.
   Defaults (which does no calibration) are substituted
   for soft iron calibration.   

Step 4 - Start Calibration-Phase 2 - and follow instructions. 
   You will be asked to rotate the device 360 degrees 
   while holding it flat on the surface.  This gathers sample data,
   adjusts for hard iron calibration, and stores in magdata360.   This last 
   sample is a circle of data which should be graphed and examined 
   manually for accuracy.   The algorithm tries to approximate the ellipse
   but should not be relied on.  


Step 5 - After manual examination of the circle of data (do step 4 several
   times until you have a perfect circle) adjust calibration record calibdata
   accordingly.    A description of calibdata is found in src/include/pmtfxos.h. 


Calibration Algorithm - Hard-Iron - Phase 1
-------------------------------------------

Step 1  create 4 datasets of (x,y) datapoints.  2000 - 5000 each
    -magdata0 - datapoints with device pointing Magnetic North
    -magdata90 - device points east
    -magdata180 - device points south
    -magdata270 - device points west


Step 2 Calculate mean, standard deviation for each dataset (except 360)
       - use means to populate matrix as follows:
  Dataset       x-value    y-value   
  ------        -------    -------   
  magdata0      Zero       Max
  magdata90     Max        Zero
  magdata180    Zero       Min
  magdata270    Min        Zero
    Zero means data is on Y-axis (x=0) or X-axis (y=0).
  
Step 3  Remove outlier data (data > (user-defined-factor * stddev from mean )
   and re-populate the matrix in step 2.  
 - Compute  Standard Deviation for x, y, and radius = SQRT( x**2 + y**2)
    = resolve to one number (average) = stddev ==> 14 uTesla
      if these numbers are not close....
        Print ERROR - Standard Deviation needs checking...
                Save to FINAL CALIBDATA sdtesla


Step 4 - Circle Radius
       - (xMax - xMin)/2 should be close (<1sd) to xZero
       - (yMax - yMin)/2 should be close (<1sd) to yZero
     Print ERROR if these numbers are not close....
     This is the diameter of the circle.  
     Save to FINAL CALIBDATA ==> 

Step 5 - Hard Iron 
------------------
     x adjustment = xmin + radius
     y adjustment = ymin + radius
    


Step 11 create file calibdata (not sure where to place it yet)
--------------------------------------------------------------
ASSUME no soft-iron calibration required
  int hardx;     /* hard iron calibration adjustment for x */ = step 5
  int hardy;     /* hard iron calibration adjustment for y */ = step 5
  int theta;     /* radians to rotate ellipse = 0
  int softx;     /* soft iron x adjustment to convert ellipse to circle = 1
  int rperfect;  /* radius of the perfect circle for this device */ =step 4
  int sdtesla;   /* standard deviation for uTesla (device noise) */ = step 3
  double sddegree;  /* standard deviation for degrees */ = step 3
  double sdf;     /* standard deviation factor 1=68%, 2=95%, 3=99.7%  */ userInput




Calibration Algorithm - Soft-Iron = Phase 2
-------------------------------------------

Step 1 - create 1 datasets of (x,y) datapoints.  2000 - 5000 points
    -magdata360 - device slowly rotates 360 degrees, 3 times
   using calibmagnet datadump for 60 sec x 40 hz = 2400 datapoints



Step 2 
   Using noise reduction via averages, find xmin, ymin, xmax, ymax.
   If these are on the circle, you are finished.   If they are not, 
   you have an ellipse.   

Step 3 (if necessary)
   Use the min and max points to form a line (assume it is through (0,0)).
   Then compute the angle of that line compared to x-axis.  Store as theta.  
   The ratio of max distance to circle radius is the softx adjustment. 
    


Step 4 create file calibdata 
--------------------------------------------------------------
  int hardx;     /* hard iron calibration adjustment for x */ = step 6
  int hardy;     /* hard iron calibration adjustment for y */ = step 6
  int theta;     /* radians to rotate ellipse for soft iron adjustment */ =step10
  int softx;     /* soft iron x adjustment to convert ellipse to circle */=step10
  int rperfect;  /* radius of the perfect circle for this device */ =step 7
  int sdtesla;   /* standard deviation for uTesla (device noise) */ = step 5
  double sddegree;  /* standard deviation for degrees */ = REMOVE ME
  double sdf;     /* standard deviation factor 1=68%, 2=95%, 3=99.7%  */ userInput

Step 5 - 
   - display xy scatter chart - should be circle or ellipse centered on (0.0).

Note - User Input Standard Deviation Factor sdf
----------------------------------------------
   1 ==> less accuracy, less noise, steady needle
   3 ==> more accuracy, more noise, wavering needle




Ecompass Operation
------------------
After calibration, you theoretically have incoming 
magnetometer data (x,y,z) from the fxos8700 where: 
(1) x**2 + y**2 = r**2  -- a perfect circle around (0,0).
(2) z = constant -- indicating the magnetometer is flat on a surface
(3) a standard deviation (SD) defining acceptable magnetometer data 
(4) user parameter of 1or2or3 Standard Deviations for acceptance 

Step 0 - Enter data accuracy 
Step 1 - read next point x1,y1 on magnetometer
Step 2 - calculate x1,y1 distance from circle center (0,0)
       -> d = SQRT(x1**2 + y1**2)
Step 3 - check point is within 1or2or3 Standard Deviations (SD)
       -> ABS(d-r) < SD else go to step 1
       - NOTE for normal distribution, 
       - 1SD=68%, 2SD=95%, 3SD=99.7% of points selected will be accepted.
Step 4 - we have valid angle theta = atan2(y1, x1)
Step 5 - noise reduction - if theta is with SD, return existing theta. 
   
int ecompass( int calibhix, int calibhiy, int calibsitheta, calibsix, stddev)
   returns degrees 0-360 of current magnetometer reading(s)


Program Structure
-----------------

daemons post degrees, dieface, action at 40 Hz
readaccelmagndata()  ==> return immediate accel, average of last 5 magn
process accel immediatley for dieface POST
if dieface == 1 >> apply calibration and compute degrees  POST
check for actions....
REPEAT


   
   NOTE FUTURE apply algorithm to calculate circle from data
 https://people.cas.uab.edu/~mosya/cl/CPPcircle.html

